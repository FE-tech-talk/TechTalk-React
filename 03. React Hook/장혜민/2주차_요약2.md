# 3장 리액트 훅
## 3.1 리액트의 모든 훅 파헤치기
### useState
- 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅
- 아무런 값도 넘겨주지 않으면 초깃값은 undefined
```js
import { useState } from 'react'

const [state, setState] = useState(initialState)
```

- 함수 내부에서 자체적으로 변수를 사용해 상태값을 관리한다면
- 매번 렌더링이 발생될 때마다 함수와 내부의 변수값은 매번 초기화된다.
- 따라서 클로저를 이용
- 게으른 초기화(lazy initialization)
    - useState에 변수 대신 함수를 넘기는 것
    - 게으른 초기화는 state가 처음 만들어 질 때만 사용
    - 리렌더링 때는 함수 실행 무시

### useEffect
- useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘.
- 첫번째 인수: 실행할 부수 효과가 포함된 함수
- 두번째 인수: 의존성 배열
- 의존성 배열의 값이 하나라도 변경되면 첫번째 인수의 콜백을 실행한다.
- 함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다.
- 클린업 함수의 목적
    - useEffect 내에서 반환되는 함수
    - 새로운 값과 렌더링된 뒤에 실행된다.
    - 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.(얕은 비교)
    - 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린없 함수를 실행한 뒤에 콜백을 실행한다.
- 의존성 배열
    - 빈 배열: 최초 렌더링때만 실행
    - 아무런 값 X: 렌더링할 때마다 실행. 컴포넌트가 렌더링됐는 지 확인할 때 사용.
    ```js
    //1
    function Component() {
        console.log('렌더링됨')
    }
    //2
    function Component() {
        useEffect(() => {
            console.log('렌더링됨')
        })
    }
    ```
    - 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장한다. useEffect 내부에서 window객체 접근에 의존하는 코드를 사용해도 된다.
    - useEffect는 컴포넌트 렌더링이 완료된 이후에 실행된다.
- 주의사항
    - 의존성 배열
    - 첫 번쨰 인수에 함수명
    - 크게 만들지 마라
    - 불필요한 외부함수X

### useMemo
- 비용이 큰 연산에 대한 결과를 저장해 두고, 저장된 값을 반환하는 훅
```js
import { useMemo } from 'react'

const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b])
```
- 첫번째 인수: 어떤 값을 반환하는 생성 함수
- 두번째 인수: 해당 함수가 의존하는 값의 배열
- 의존성 배열이 변경되면 첫번째 인수의 함수를 재실행해 그 값을 반환하고 저장
- 메모이제이션은 컴포넌트도 가능(React.memo)

### useCallback
- 인수로 넘겨받은 콜백 자체를 기억한다. 특정함수를 새로 만들지 않고 재사용한다.
- 첫번쨰 인수: 함수
- 두번째 인수: 의존성 배열
- 해당 의존성이 변경됐을 때만 함수가 재생성된다.
- 기명함수를 넘겨주면 디버깅에 용이하다.

### useRef
- useState 공통점: 컴포넌트 내부에서 랜더링이 일어나도 변경 가능한 상태값을 저장한다
- 차이점: useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다. 그리고 값이 변하더라도 렌더링이 일어나지 않는다.
- 컴포넌트가 렌더링될 때만 생성되며, 컴포넌트 인스턴스가 여러개라도 각각 별개의 값을 바라본다.
```jsx
function RefComponent() {
    const inputRef = uesRef()

    console.log(inputRef.current)// undefined

    useEffect(() => {
        console.log(inputRef.current)// <input type="txt"></input>
    }, [inputRef])

    return <input ref={inputRef} type="text" />
}
```

### useContext
- Context: prop 내려주시(props drilling)을 극복하기 위해 등장
- Context를 함수 컴포넌트에서 사용할 수 있게 해주는 훅
- useContext는 Provider와 의존성을 갖는다.
- 단순히 상태를 주입하는 기능, 상태관리 X

### useReducer
- useState의 심화버전. 복잡한 상태값을 정해진 시나리오에 따라 관리할 수 있다.
- 반환값(길이가 2인 배열)
    - state: 현재 useReducer가 가진 값
    - dispatcher: state를 업데이트하는 함수. action을 넘겨준다.
- 인수
    - reducer: 기본 action을 정의하는 함수. 이 reducer는 useReducer의 첫 번째 인수로 넘겨주어야 한다
    - initialState: 초깃값
    - init: 필수값 X. 초깃값을 지연해서 생성시키고 싶을 때 사용. 게으른 초기화

### useImperativeHandle
- 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅

### useLayoutEffect
- 이 함수의 시그니처는 useEffect와 동일하나, 모든 DOM의 변경 후에 동기적으로 발생한다.
- DOM은 계산됐지만 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용.

### useDebugValue
- 개발 과정에서 디버깅하고 싶은 정보를 훅에 넣어 사용

### 훅의 규칙
- 최상위에서만 훅을 호출해야한다. 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
- 리액트 함수 컴포넌트, 사용자 정의 훅에서만 훅을 호출할 수 있다.