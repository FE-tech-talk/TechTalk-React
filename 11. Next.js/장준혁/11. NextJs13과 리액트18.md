## 1. app 디렉터리의 등장

### app 디렉터리의 등장

NextJS 13버전 이전까지 모든 페이지는 각각의 물리적인 파일로 독립돼 있었다.
공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했지만 app 레이아웃이 나오게 되었다.

### 라우팅

NextJS13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 끼치지 않는다.

- layout.js : 페이지의 기본적인 레이아웃을 구성하는 요소이다. 주소별 공통 UI를 포함할 수 있을뿐만 아니라 공통 코드를 삽입할 수도 있다.
- page.js : 일반적으로 다루었던 페이지이다.
- error.js : 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트이다. 에러 바운더리는 클라이언트 컴포넌트에서만 작동한다.
- not-found.js : 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링한다.
- loading.js : 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용한다
- route.js : 디렉터리가 라우팅 주소를 담당하고 파일명은 route.ts로 통일됐다.

## 2. 리액트 서버 컴포넌트

### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

리액트의 모든 컴포넌트는 클라이언트에서 작동하며 브라우저에서 자바스크립트 코드 처리가 이루어진다.
서버 사이드 렌더링은 미리 서버에서 DOM을 만들어 오고 클라이언트에서 하이드레이션을 실행한다.

기존 구조의 문제점은 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없고 백엔드 리소스에 직접적인 접근이 불가능했으며 자동 코드 분할이 불가능, 연쇄적으로 발생하는 클라이언트와 서버 요청을 대응하기 어려움, 추상화에 대한 어려움이 있었다.
리액트가 클라이언트 중심으로 돌아가기 때문에 생긴 문제이며 클라이언트 사이드 렌더링은 사용자의 인터랙션에 따라 다양한 것을 제공할 수 있으나 서버에 비해 느리고 데이터를 가져오는 것이 어려웠다.

### 서버 컴포넌트란?

서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법이다.
서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행된다.
클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다. children으로 가져올 수는 있다.

서버컴포넌트

- 요청이 오면 그 순간 서버에서 딱 한 번 실행되어 상태를 가질 수 없다.
- 한번 렌더링되면 끝이므로 렌더링 생명주기를 사용할 수 없다.
- 마찬가지로 effect, state에 의존하는 훅을 사용할 수 없다.
- 브라우저에서 실행되지 않기 때문에 DOM API를 쓰거나 window, document에 접근이 불가능하다.
- db, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있다.
- 다른 서버 컴포넌트와 클라이언트 컴포넌트를 렌더링 할 수 있다.

클라이언트 컴포넌트

- 브라우저 환경에만 실행되므로 서버 컴포넌트를 불러오거나 서버 전용 훅이나 유틸리티를 사용할 수 없다.
- 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다. 클라이언트 컴포넌트 입장에서 서버 컴포넌트가 이미 서버에서 만들어진 트리를 가지고 있어 클라이언트 컴포넌트가 삽입하여 보여주면 되기 때문이다.
- 두 상황을 제외하면 일반적인 리액트 컴포넌트와 같다.

공용 컴포넌트

- 서버와 클라이언트 모두 사용할 수 있다.

### 서버 사이드 렌더링과 서버 컴포넌트의 차이

서버 사이드 렌더링은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에서 내려준다.
그 이후 클라이언트에서 하이드레이션하는 과정을 거쳐 서버의 결과물을 확인하여 이벤트를 붙인다.
따라서, 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고 파싱하고 실행하는데 비용이 든다.

서버 컴포넌트를 활용하여 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 빠르게 전달받을 수 있다.

### 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트이다.
2. 서버는 받은 요청에 따라 JSON으로 직렬화한ㄷ. 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 플레이스홀더 형식으로 비워두고 나타낸다. 이후 브라우저가 결과물을 받아 역직렬화를 하여 렌더링을 수행한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 결과물을 바탕으로 트리를 재구성하여 컴포넌트를 만들어 나간다.

서버 컴포넌트의 작동 방식의 특별한 점

- 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저가 사용자에게 빨리 결과물을 보여줄 수 있다.
- 컴포넌트들이 각 컴포넌트별로 번들링이 별개로 돼 있어 지연해서 받거나 따로 받을 수 있다.
- 결과물이 HTML이 아닌 JSON 형태로 보내진다. JSON으로 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와준다.

## 3. NextJS에서의 리액트 서버 컴포넌트

NextJS에서 기본적인 서버 컴포넌트의 제약은 동일하다.

### 새로운 fetch의 도입과 getServerSideProps, getStaticProps, getInitialProps 삭제

모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이루어진다.
SWR과 React Query와 비슷하게, 해당 fetch 요청에 대한 내용을 서버에서 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

### 정적 렌더링과 동적 렌더링

정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용한다. 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링한다.
캐싱을 하지 않는 no-cache 옵션도 제공한다.
쿠키 정보를 불러오는 함수를 사용하게 된다면 동적인 연산을 바탕으로 결과를 반환하여 정적 렌더링 대상에서 제외된다.

동적인 주소지만 특정 주소에 대해 캐싱하고 싶은 경우 getStaticPath대신 generateStaticParams를 사용하면 된다.

### 캐시와 mutating, 그리고 revalidating

revalidate로 해당 데이터의 유효시간을 정해두고 시간이 지나면 다시 데이터를 불러와 렌더링 하는 것이 가능하다.
캐시를 무효화하고 싶다면 router에 추가된 refresh()를 사용하면 된다.

### 스트리밍을 활용한 점진적인 페이지 불러오기

하나의 페이지가 다 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍을 사용한다.
최초 바이트까지의 시간 (TTFB), 최초 콘텐츠풀 페인팅 (FCP)을 개선한다.

스트리밍을 활용할 수 있는 방법은 두가지가 있는데 loading.tsx와 Suspense를 사용할 수 있다.

## 4. 웹팩의 대항마, 터보팩의 등장

새롭게 뜨고있는 라이브러리인 Rome, SWC, esbuild는 자바스크립트로 만들어진 기능을 Rust나 Go 같은 다른 언어를 사용해 제공한다.
Next.JS 13에서는 웹팩의 후계자를 자처하는 터보팩이 출시됐다. 웹팩 대비 700배, vite 대비 최대 10개 빠르다고한다.
13.1.x기준으로 터보팩은 베타이며 개발 모드에서만 제한적으로 사용이 가능하다.

## 5. 서버 액션(alpha)

API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청을 수행할 수 있다.

### form의 action

form의 action으로 넘겨주었을 때 이벤트를 발생시키는 것은 클라이언트지만 함수 자체가 수행되는 것은 서버가 될 수 있다.
폼과 실제 노출하는 데이터가 연동돼 있을 때 더 효과적으로 사용이 가능하다.

input의 submit과 image의 formAction, startTransition과의 연동이 가능하다.

### server mutation이 없는 작업

별도의 server mutation을 실행하지 않는다면 이벤트 핸들러에서 사용이 가능하다.

### 서버 액션 사용 시 주의할 점

- 클라이언트 컴포넌트 내에서 정의될 수 없다.
- props형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능하다.

## 6. 그 밖의 변화

프로젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화 됐고, SEO를 쉽게 작성할 수 있는 기능이 추가돼었으며 정적으로 내부 링크를 분석할 수 있는 기능이 있다.

## 7. Nst.JS 13 코드 맛보기

getServerSideProps와 비슷한 서버사이드 렌더링을 구성할 수 있고 getStaticProps와 비슷한 정적인 페이지 렌더링을 구현할 수 있으며 로딩, 스트리밍, 서스펜스를 사용하여 컴포넌트가 렌더링 중이라는 것을 나타낼 수 있다.
