# 서버 사이드 렌더링
## 4.1 서버 사이드 렌더링이란
### 4.1.1 싱글 페이지 애플리케이션의 세상

#### 싱글 페이지 애플리케이션이란?
- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 페이지를 불러온 이후에는 서버에서 HTML을 내려 받지 않고 하나의 페이지에서 모든 작업을 처리.

#### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교
- 과거 : 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 파싱. 사용자 입장에서는 페이지가 처음부터 만들어지는 것처럼 보인다.
- 싱글페이지: 페이지 전환을 자바스크립트로 한다면 최초 리소스를 다운로드하고 이후 페이지를 전환할 떄 매끄러운 UI를 보여줄 수 있다.

#### 싱글 페이지 렌더링 방식의 JAM 스택의 등장
- 과거 PHP나 JSP 기반 웹 애플리케이션 : 렌더링 서버사이드, JS는 사용자에서 추가적인 경험을 주는 보조적인 수단
- 모듈화 논의, CommonJs와 AMD 등장, 기기 성능 향상, 인터넷 속도 발전
- 자바스크립트 수준에서 MVx 프레임워크 구현 
- 과거 LAMP 스택
- JAM스택: 자바스크립트랑 마크업을 미리 빌드해 두고 정적으로 사용자에게 제공. 이후 작동은 사용자의 클라이언트에서 실행. (서버확장성 증가)
- MERN스택: API서버 자체도 자바스크립트로 구현하는 구조

### 4.1.2 서버 사이드 렌더링이란?
- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식.
- 차이
    - 싱글 페이지 어플리케이션: 사용자에게 제공되는 자바스크립트 번들에서 렌더링
    - 서버 사이드 방식: 렌더링에 필요한 방식을 모두 서버에서 수행

#### 서버 사이드 렌더링의 장점
- 최초 페이지 진입이 비교적 빠르다. 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 서버 사이드 렌더링이 더 빠를 수 있다.
- 검색 엔진과 메타데이터 제공이 쉽다.
- 누적 레이아웃 이동이 적다.
- 사용자의 디바이스 성능에 비교적 자유롭다. 
- 보안에 좀 더 안전하다. 서버 사이드 렌더링의 경우 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다.

#### 단점
- 소스코드를 작성할 때 항상 서버를 고려해야 한다. window 등 브라우저에만 있는 전역 객체를 서버에서 실행된다면 에러를 마주치게 된다.
- 적절한 서버가 구축돼 있어야 한다. 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하다.
- 서비스 지연에 따른 문제. 최초 렌더링에서 지연이 발생하면 사용자가 작업이 진행 중임을 알 수 없다.

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유
- 잘못된 웹페이지 설계는 성능 저하, 서버와 클라이언트 두 군데로 관리 포인트만 늘어남.
- SPA: 브라우저 API와 자바스크립트를 활용한 라우팅 기반으로 한 매끄러운 라우팅
- 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션보다 느리다.
- 현대의 서버 사이드 렌더링은 최초 웹사이트 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션 처럼 작동한다.

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기
- 리액트 브라우저 자바스크립 환경에서 렌더링
- 서버에서 렌더링할 수 있는 API도 제공
    - react-dom/server.js의 기본적인 함수(renderToString, renderToStaticMarkup, renderToNodeStream, renderToStaticNodeStream)

### 4.2.1 renderToString
- 인수로 넘겨 받은 리액트 컴포넌트를 렌더링해 HTML문자열로 반환하는 함수
- 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 해주지 않는다.
- data-reactroot: 리액트 컴포넌트의 루트 엘리먼트를 식별하는 역할. 자바스크립트를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점이 된다.

### 4.2.2 renderToStaticMarkup
- renderToString과 유사. 리액트 컴포넌트를 기준으로 HTML 문자열을 만든다.
- 차이점: 루트 요소에 추가한 data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
- 리액트의 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 만들 때만 사용한다.

### 4.2.3 renderToNodeStream
- renderToString과 결과물이 동일. 2가지 차이점
- renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능하다.
- renderToString은 결과물 타입이 string이고, renderToNodeStream은 결과물 타입이 Node.js의 ReadableStream이다.
- 큰 크기의 데이터를 청크 단위로 분리해 순차적으로 처리할 수 있다.

### 4.2.4 renderToStaticNodeStream
- renderToNodeStream과 제공하는 결과물은 동일.
- 리액트 자바스크립트에 필요한 리액트 속성 제공X
- 순수 HTML결과물이 필요할 때 사용

### 4.2.5 hydrate
- renderToString, renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할.
- 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행된다.

## 4.3 Next.js 톺아보기
### 4.3.1 Next.js란?
- 풀스택 웹 애플리케이션을 구축하기 위한 리액트 기반 프레임워크
- 서버 사이드 렌더링 염두
- 디렉터리 기반 라우팅

### 4.3.2 Next.js 시작하기
- `npx create-next-app@latest --ts`

#### package.json
- 프로젝트 구동에 필요한 모든 명령어 및 의존성이 포함

#### next.config.js
- 프로젝트의 환경 설정

#### pages/_app.tsx
- 애플리케이션 전체 페이지의 시작점
- 에러 바운더리를 사용해 애플리케이션 전역에서 발생하는 에러 처리
- reset.css같은 전역 CSS 선언
- 모든 페이지에 공통으로 사용 또는 제공해야하는 데이터 제공

#### pages_document.tsx
- create-next-app 기본 파일 아님
- 애플리케이션의 HTML을 초기화하는 곳
- DOM 속성을 추가하고 싶을 때 사용
- 서버에서 실행. 이벤트 핸들러 추가 불가능
- CSS-in-JS의 스타일을 서버에서 모아 HTML로 제공

#### pages/_error.tsx
- create-next-app 기본 파일 아님
- 클라이언트에서 발생하는 에러
- 서버에서 발생하는 500에러
- 개발모드에서 확인 불가능
- 프로덕션으로 빌드해서 확인

#### pages/404.tsx
- 404 페이지를 정의할 수 있는 파일

#### pages/500/tsx
- 서버에서 발생하는 에러를 핸들링하는 페이지
- _error.tsx와 500.tsx가 모두 있다면 500.tsx가 우선 실행

#### pages/index.tsx
- 지금까지는 예약어로 관리되는 페이지.
- 개발자가 명칭 지정해 만들 수 있는 페이지.
- 라우팅 구조는 /pages 디렉터리를 기초로 구성
- []안의 값을 변수처럼 사용
- [...props] 전개연산자로 선언한 모든 주소는 배열로 들어간다.

##### 서버 라우팅과 클라이언트 라우팅의 차이
- `<a>` 서버에서 렌더링을 수행하고, 클라이언트에서 hydrate하는 과정에서 한 번 더 실행
- `<Link>` 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식

##### getServerSideProps
- 페이지에서 getServerSideProps를 제거하면 서버에 로그가 남지 않는다.
- O: 서버 사이드 런타임 체크가 됨
- X: 빌드 크기 감소, 서버 사이드 렌더링이 필요없는 정적인 페이지
- Next.js는 서버 사이드 렌더링 프레임워크이지만 모든 작업이 서버에서 일어나는 것은 아니다.

#### /pages/api/hello.js
- 서버의 API를 정의하는 폴더

### 4.3.3 Data Fetching
- 

