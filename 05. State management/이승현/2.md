## 리액트 훅으로 시작하는 상태 관리

### useState와 useReducer

지역 상태 관리를 위해 만들어졌다.

해당 컴포넌트에서만 유효하다는 한계가 있다. (컴포넌트별로 초기화되며 서로 다른 상태를 가진다.)

state lifting으로 하나의 state로 여러 컴포넌트를 다룰 수 있지만 props 형태로 관리해야한다는 것이 불편하다.
(컴포넌트 트리 재설계 필요)

### useState의 상태를 바깥으로 분리

클로저를 이용해서 전역으로 변수를 뺀 후에 접근하는 방식 > 렌더링이 발생하지 않음. > 지역 setter와 함께 사용 > 되긴 되는데 비효율적이고 다른 컴포넌트와 함께 쓸 수 없다. (해당 컴포넌트의 setter만 작동하여 그 컴포넌트만 렌더링하기 때문에)

#### 결국 만족해야할 조건

1. 컴포넌트 외부 어딘가에 상태를 두고 다른 컴포넌트도 쓸 수 있어야함.
2. 상태의 변화를 모든 컴포넌트가 알아야 하고 참조하는 모든 컴포넌트가 리렌더링이 일어나야 함.
3. 상태에 객체가 있을 경우 통째로 바뀌지 않는 한 리렌더링이 일어나선 안된다.

useState를 사용해서 구현한 전역 상태 관리는 하나의 스토어만 가질 수 있다는 한게가 있었다.

#### 현재 상태 관리 라이브러리들의 규칙

1. useState, useReducer가 가지고 있는 한계를 극복하기 위해 외부 어딘가에 상태를 둔다.
2. 각자의 방식으로 변화를 감지해 리렌더링

## Recoil, Jotai, Zustand

Recoil, Jotai : Context와 Provider 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데 초점을 맞추고 있다.
Zustand : 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리, Context가 아닌 스토어가 가지는 클로저를 기반으로 생성, 상태가 변경되면 구독중인 컴포넌트에 전파, 리렌더링시킴.

### Recoil

#### RecoilRoot

최상위 컴포넌트에서 선언해야한다.

RecoilRoot로 생성된 Context의 스토어에 저장

해당 상태의 setter가 있으며 변경될 시 하위 컴포넌트들에게 알림

#### atom

상태를 나타내는 Recoil의 최소 상태 단위

#### useRecoilValue

atom의 값을 읽어오는 훅

#### useRecoilState

atom의 값을 가져오고 변경하는 훅

### Jotai

Bottom-up 접근법을 취하고 있는 라이브러리
(작은 단위의 상태를 위로 전파할 수 있는 구조)

Recoil과 같이 atom 개념을 도입했지만 API가 간결하다.

#### atom

최소 단위의 상태, Recoil과는 다른게 이거 하나로 파생된 상태까지 만들 수 있다.

#### useAtomValue

최신 값의 atom을 사용해 렌더링

#### useAtom

atom의 현재 값, setter 제공

### Zustand

리덕스에 영감을 받아 만들어진 라이브러리, 하나의 스토어를 중앙 집중형으로 활용해 내부에서 상태 관리

작은 번들 사이즈, 가볍고 편리하다.